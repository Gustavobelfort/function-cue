package xs3bucket

// generated by xp-function-cue, DO NOT EDIT
_script: "package runtime\n\nimport (\n\t\"list\"\n\t\"encoding/json\"\n)\n\nlet endpoints0 = [\n\tfor s in _suffixes {\n\t\tlet bucketName_1 = \"bucket\\(s)\"\n\t\t[\n\t\t\tif _request.observed.resources[bucketName_1].resource.status.atProvider.bucketRegionalDomainName != _|_ // explicit error (_|_ literal) in source\n\t\t\t{\n\t\t\t\t_request.observed.resources[bucketName_1].resource.status.atProvider.bucketRegionalDomainName\n\t\t\t}, \"unknown\"][0]\n\t}]\nlet endpoints1 = [ for e in endpoints0 if e != \"unknown\" {\n\te\n}]\nlet resource0 = [\n\tif _request.observed.resources.main.resource.status.atProvider.arn != _|_ // explicit error (_|_ literal) in source\n\t{\n\t\tr: _request.observed.resources.main.resource.status.atProvider.arn\n\t}, {\n\t\tr: \"unknown\"\n\t}][0].r\nlet arns0 = [\n\tfor s in _suffixes {\n\t\tlet bucketName_2 = \"bucket\\(s)\"\n\t\t[\n\t\t\tif _request.observed.resources[bucketName_2].resource.status.atProvider.arn != _|_ // explicit error (_|_ literal) in source\n\t\t\t{\n\t\t\t\t_request.observed.resources[bucketName_2].resource.status.atProvider.arn\n\t\t\t}, \"unknown\"][0]\n\t}]\nlet arns1 = [ for e in arns0 if e != \"unknown\" {\n\te\n}]\n{\n\tresources: {\n\t\tfor s in _suffixes {\n\t\t\tlet bucketName = \"bucket\\(s)\"\n\t\t\t\"\\(bucketName)\": {\n\t\t\t\tresource: {\n\t\t\t\t\tapiVersion: \"s3.aws.upbound.io/v1beta1\"\n\t\t\t\t\tkind:       \"Bucket\"\n\t\t\t\t\tmetadata: name: \"\\(_composite.metadata.name)\\(s)\"\n\t\t\t\t\tspec: forProvider: {\n\t\t\t\t\t\tforceDestroy: true\n\t\t\t\t\t\tregion:       _spec.parameters.region\n\t\t\t\t\t\ttags:         _tags\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tready: (#readyValue \u0026 {\n\t\t\t\t\tin: _request.observed.resources[bucketName].resource.status.conditions\n\t\t\t\t}).out\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(endpoints1) == len(_suffixes) \u0026\u0026 len(_suffixes) \u003e 0 {\n\t\tcomposite: resource: status: additionalEndpoints: endpoints1\n\t}\n}\n{\n\t// if we have all the ARNs, why not create a policy?\n\tif len(arns1) == len(_suffixes) \u0026\u0026 resource0 != \"unknown\" {\n\t\tlet resources0 = list.FlattenN(list.Concat([[\"\\(resource0)\", \"\\(resource0)/*\"], [\n\t\t\tfor a in arns1 {\n\t\t\t\t[\"\\(a)\", \"\\(a)/*\"]\n\t\t\t}]]), 1)\n\t\tresources: iam_policy: {\n\t\t\tresource: {\n\t\t\t\tapiVersion: \"iam.aws.upbound.io/v1beta1\"\n\t\t\t\tkind:       \"Policy\"\n\t\t\t\tmetadata: name: \"\\(_composite.metadata.name)-access-policy\"\n\t\t\t\tspec: forProvider: {\n\t\t\t\t\tpath:   \"/\"\n\t\t\t\t\tpolicy: json.Marshal({\n\t\t\t\t\t\tVersion: \"2012-10-17\"\n\t\t\t\t\t\tStatement: [{\n\t\t\t\t\t\t\tSid: \"S3BucketAccess\"\n\t\t\t\t\t\t\tAction: [\"s3:GetObject\", \"s3:PutObject\"]\n\t\t\t\t\t\t\tEffect:   \"Allow\"\n\t\t\t\t\t\t\tResource: resources0\n\t\t\t\t\t\t}]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tready: (#readyValue \u0026 {\n\t\t\t\tin: _request.observed.resources.iam_policy.resource.status.conditions\n\t\t\t}).out\n\t\t}\n\t}\n\n\t// set the policy ARN on the status if found\n\tif _request.observed.resources.iam_policy.resource.status.atProvider.arn != _|_ // explicit error (_|_ literal) in source\n\t{\n\t\tcomposite: resource: status: iamPolicyARN: _request.observed.resources.iam_policy.resource.status.atProvider.arn\n\t}\n}\n{\n\tresources: main: {\n\t\tresource: {\n\t\t\tapiVersion: \"s3.aws.upbound.io/v1beta1\"\n\t\t\tkind:       \"Bucket\"\n\t\t\tmetadata: name: _composite.metadata.name\n\t\t\tspec: forProvider: {\n\t\t\t\tforceDestroy: true\n\t\t\t\tregion:       _spec.parameters.region\n\t\t\t\ttags:         _tags\n\t\t\t}\n\t\t}\n\t\tready: (#readyValue \u0026 {\n\t\t\tin: _request.observed.resources.main.resource.status.conditions\n\t\t}).out\n\t}\n\n\t// set the primary endpoint on the status if found\n\tif _request.observed.resources.main.resource.status.atProvider.bucketRegionalDomainName != _|_ // explicit error (_|_ literal) in source\n\t{\n\t\tcomposite: resource: status: primaryEndpoint: _request.observed.resources.main.resource.status.atProvider.bucketRegionalDomainName\n\t}\n}\n\n// responses should be generated based on the _request object. The variable below declares it as an open struct\n// so that it can be referenced in expressions.\n_request: {\n\t...\n}\n\n// create some hidden fields for easy access to nested JSON paths and provide defaults\n_composite: _request.observed.composite.resource\n_spec:      _composite.spec\n_tags:      [\n\t\tif _composite.spec.parameters.tags != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\t\t_composite.spec.parameters.tags\n\t\t}, {}][0]\n_suffixes: [\n\t\tif _spec.parameters.additionalSuffixes != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\ts: _spec.parameters.additionalSuffixes\n\t}, {\n\t\ts: []\n\t}][0].s\n\n// #listWithDefault returns a list guaranteed to have a specific element at its end. The input list\n// may not be present but if it is, must be a real list.\n// use as: (#listWithDefault \u0026 { in: some.path.to.list, def: { \"foo\": \"bar\" } }).out\n#listWithDefault: {\n\tx=in:  _\n\ty=def: _\n\tout:   [\n\t\tif x != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\t\tlist.Concat([x, [y]])\n\t\t}, [y]][0]\n}\n#readyValue: {\n\tx=in:    _\n\ty= _tmp: (#listWithDefault \u0026 {\n\t\tin: x\n\t\tdef: {\n\t\t\ttype:   \"Ready\"\n\t\t\tstatus: \"Unknown\"\n\t\t}\n\t}).out\n\tz= _readyValue: [ for r in y if r.type == \"Ready\" {\n\t\tr.status\n\t}][0]\n\tout: [\n\t\tif z == \"True\" {\n\t\t\tready: \"READY_TRUE\"\n\t\t},\n\t\tif z == \"False\" {\n\t\t\tready: \"READY_FALSE\"\n\t\t}, {\n\t\t\tready: \"READY_UNSPECIFIED\"\n\t\t}][0].ready\n}\n"
