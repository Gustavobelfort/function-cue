package scripts

// generated by xp-function-cue, DO NOT EDIT
s3bucket: "package s3bucket\n\nimport (\n\t\"list\"\n\t\"encoding/json\"\n)\n\nlet endpoints0 = [\n\tfor s in _suffixes {\n\t\tlet bucketName_1 = \"bucket\\(s)\"\n\t\t[\n\t\t\tif _request.observed.resources[bucketName_1].resource.status.atProvider.bucketRegionalDomainName != _|_ // explicit error (_|_ literal) in source\n\t\t\t{\n\t\t\t\t_request.observed.resources[bucketName_1].resource.status.atProvider.bucketRegionalDomainName\n\t\t\t}, \"unknown\"][0]\n\t}]\nlet endpoints1 = [for e in endpoints0 if e != \"unknown\" {\n\te\n}]\nlet mainARN = _request.observed.resources.main.resource.status.atProvider.arn\nlet baseARN = [\n\tif mainARN != _|_ // explicit error (_|_ literal) in source\n\t{\n\t\tmainARN\n\t}, \"unknown\"][0]\nlet arns = [\n\tfor s in _suffixes {\n\t\tlet bucketName_2 = \"bucket\\(s)\"\n\t\tlet arn_1 = _request.observed.resources[bucketName_2].resource.status.atProvider.arn\n\t\t[\n\t\t\tif arn_1 != _|_ // explicit error (_|_ literal) in source\n\t\t\t{\n\t\t\t\tarn_1\n\t\t\t}, \"unknown\"][0]\n\t}]\nlet additionalARNs = [for e in arns if e != \"unknown\" {\n\te\n}]\nlet p = _request.observed.resources.main.resource.status.atProvider.bucketRegionalDomainName\n{\n\tresources: {\n\t\tfor s in _suffixes {\n\t\t\tlet bucketName = \"bucket\\(s)\"\n\t\t\t(bucketName): resource: {\n\t\t\t\tapiVersion: \"s3.aws.upbound.io/v1beta1\"\n\t\t\t\tkind:       \"Bucket\"\n\t\t\t\tmetadata: name: \"\\(_compName)\\(s)\"\n\t\t\t\tspec: forProvider: {\n\t\t\t\t\tforceDestroy: true\n\t\t\t\t\tregion:       _spec.parameters.region\n\t\t\t\t\ttags:         _tags\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// only render additional endpoints if all of them are available since it is an ordered list\n\t// that matches the suffix list\n\tif len(endpoints1) == len(_suffixes) \u0026\u0026 len(_suffixes) \u003e 0 {\n\t\tcomposite: resource: status: additionalEndpoints: endpoints1\n\t}\n}\n{\n\t// if we have a base ARN, render a policy with that and any additional ARNs available.\n\tif baseARN != \"unknown\" {\n\t\tlet allTuples = list.Concat([[baseARN, baseARN + \"/*\"], [\n\t\t\tfor a in additionalARNs {\n\t\t\t\t[a, a + \"/*\"]\n\t\t\t}]])\n\t\tlet allResources = list.FlattenN(allTuples, 1)\n\t\tresources: iam_policy: resource: {\n\t\t\tapiVersion: \"iam.aws.upbound.io/v1beta1\"\n\t\t\tkind:       \"Policy\"\n\t\t\tmetadata: name: \"\\(_compName)-access-policy\"\n\t\t\tspec: forProvider: {\n\t\t\t\tpath: \"/\"\n\t\t\t\tpolicy: json.Marshal({\n\t\t\t\t\tVersion: \"2012-10-17\"\n\t\t\t\t\tStatement: [{\n\t\t\t\t\t\tSid: \"S3BucketAccess\"\n\t\t\t\t\t\tAction: [\"s3:GetObject\", \"s3:PutObject\"]\n\t\t\t\t\t\tEffect:   \"Allow\"\n\t\t\t\t\t\tResource: allResources\n\t\t\t\t\t}]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tlet policyARN = _request.observed.resources.iam_policy.resource.status.atProvider.arn\n\t\tif policyARN != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\t\tcomposite: resource: status: iamPolicyARN: policyARN\n\t\t}\n\t}\n}\n{\n\tif p != _|_ // explicit error (_|_ literal) in source\n\t{\n\t\tcomposite: resource: status: primaryEndpoint: p\n\t}\n}\n\n// responses should be generated based on the _request object. The variable below declares it as an open struct\n// so that it can be referenced in expressions.\n_request: {\n\t...\n}\n\n// create some hidden fields for easy access to nested JSON paths and provide defaults\n_composite: _request.observed.composite.resource\n_compName:  _composite.metadata.name\n_spec:      _composite.spec\n_tags:      [\n\t\tif _composite.spec.parameters.tags != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\t_composite.spec.parameters.tags\n\t}, {}][0]\nresources: main: resource: {\n\tapiVersion: \"s3.aws.upbound.io/v1beta1\"\n\tkind:       \"Bucket\"\n\tmetadata: name: _compName\n\tspec: forProvider: {\n\t\tforceDestroy: true\n\t\tregion:       _spec.parameters.region\n\t\ttags:         _tags\n\t}\n}\n_suffixes: [\n\t\tif _spec.parameters.additionalSuffixes != _|_ // explicit error (_|_ literal) in source\n\t\t{\n\t\t_spec.parameters.additionalSuffixes\n\t}, []][0]\n"
