package cuetools

import (
    "bytes"
    "fmt"
    "os"
    "os/exec"
    "encoding/json"
    "path/filepath"

    "github.com/pkg/errors"
)

const generator = "fn-cue-tools"

func runDefCommand(dir string) (_ []byte, finalErr error) {
    // Change working directory to the target directory
    err := os.Chdir(dir)
    if err != nil {
        return nil, errors.Wrap(err, "change working directory")
    }

    // Print current directory and list files for debugging
    cwd, _ := os.Getwd()
    fmt.Println("Current working directory:", cwd)
    files, err := filepath.Glob("*")
    if err != nil {
        return nil, errors.Wrap(err, "list files in directory")
    }
    fmt.Println("Files in directory:", files)

    // Execute the cue def command
    cmd := exec.Command("cue", "def", "--inline-imports", ".")
    var out bytes.Buffer
    var stderr bytes.Buffer
    cmd.Stdout = &out
    cmd.Stderr = &stderr

    if err := cmd.Run(); err != nil {
        return nil, errors.Wrapf(err, "cue def command failed with stderr: %s", stderr.String())
    }

    return out.Bytes(), nil
}

type OutputFormat string

const (
    FormatRaw OutputFormat = "raw"
    FormatCue OutputFormat = "cue"
)

type PackageScriptOpts struct {
    Format        OutputFormat // output format
    OutputPackage string       // package to declare for cue output
    VarName       string       // variable name to use for cue output, default _script
}

// PackageScript generates self-contained definitions from the supplied directory and returns cue code for an object
// with a _script property that contains the code as a string. The returned object has a package declaration
// for the package supplied.
func PackageScript(dir string, opts PackageScriptOpts) (_ []byte, finalErr error) {
    defs, err := runDefCommand(dir)
    if err != nil {
        return nil, err
    }

    if opts.Format == FormatRaw {
        return defs, nil
    }

    header := ""
    if opts.OutputPackage != "" {
        header = "package " + opts.OutputPackage
    }
    jsonString, _ := json.Marshal(string(defs))

    varName := opts.VarName
    if varName == "" {
        varName = "_script"
    }
    outputCode := fmt.Sprintf(`%s

// generated by %s, DO NOT EDIT
%s: %s
`, header, generator, varName, jsonString)
    return []byte(outputCode), nil
}
